import React, { useState, useMemo, useRef, useEffect } from 'react';
import {
  AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell,
  XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend
} from 'recharts';
import {
  TrendingUp, Users, Clock, DollarSign, PieChart as PieIcon,
  Info, RefreshCw, Activity, MapPin,
  Settings, Briefcase, Printer, Calculator, LayoutDashboard,
  Scale, ArrowUpRight, Save, FileText, ChevronUp, ChevronDown, Zap, ShoppingBag, Wrench, Percent,
  Plus, Trash2, Edit2, X, Calendar, Truck, Check, Database, List, BarChart3, Filter, Search, Copy, Share2, LogOut, Loader2
} from 'lucide-react';

import { DashboardMetrics, PricingCalculatorInputs, Order, OrderStatus, Filament, FilamentMaterial, ReplacementPart, PartCategory } from './types';
import {
  fetchOrders, upsertOrder, deleteOrder,
  fetchFilaments, upsertFilament, deleteFilament,
  fetchParts, upsertPart, deletePart,
  calculateDashboardMetrics, formatCurrency
} from './services/dataService';
import StatCard from './components/StatCard';
import Auth from './components/Auth';
import { supabase } from './services/supabase';
import { User } from '@supabase/supabase-js';

import { MONTH_NAMES, BRAZILIAN_STATES, DEFAULT_COSTS_CONFIG, generateMockOrders } from './constants';

const EMPTY_ORDER: Partial<Order> = {
  customer: '',
  pieceName: '',
  material: '',
  color: '',
  state: '',
  status: undefined,
  quantity: 1,
  unitValue: 0,
  unitCost: 0,
  time: 0,
  freight: 0,
  powerConsumption: 0,
  laborTime: 0,
  weight: 0,
  shippingDate: '',
  date: new Date().toISOString().split('T')[0]
};

const App: React.FC = () => {
  const [user, setUser] = useState<User | null>(null);
  const [authLoading, setAuthLoading] = useState(true);

  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setAuthLoading(false);
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
    });

    return () => subscription.unsubscribe();
  }, []);

  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().getMonth();

  const [activeTab, setActiveTab] = useState<'dashboard' | 'calculator' | 'orders' | 'inventory' | 'parts'>('dashboard');
  const [selectedYear, setSelectedYear] = useState(currentYear);
  const [selectedMonth, setSelectedMonth] = useState(currentMonth);
  const [selectedDay, setSelectedDay] = useState<string>('');
  const [statusFilter, setStatusFilter] = useState<OrderStatus | 'Todos'>('Todos');
  const [dashboardScope, setDashboardScope] = useState<'month' | 'year' | 'all'>('month');

  const [expandedSections, setExpandedSections] = useState({
    piece: true,
    material: true,
    labor: true,
    machine: true
  });

  const toggleSection = (section: keyof typeof expandedSections) => {
    setExpandedSections(prev => ({ ...prev, [section]: !prev[section] }));
  };

  const [isOrderModalOpen, setIsOrderModalOpen] = useState(false);
  const [isSummaryModalOpen, setIsSummaryModalOpen] = useState(false);
  const [summaryText, setSummaryText] = useState('');
  const [editingOrderId, setEditingOrderId] = useState<string | null>(null);
  const [openStatusDropdownId, setOpenStatusDropdownId] = useState<string | null>(null);
  const [isOrderMaterialDropdownOpen, setIsOrderMaterialDropdownOpen] = useState(false);
  const [isStateDropdownOpen, setIsStateDropdownOpen] = useState(false);
  const [isOrderStatusDropdownOpen, setIsOrderStatusDropdownOpen] = useState(false);

  const [isFilamentModalOpen, setIsFilamentModalOpen] = useState(false);
  const [editingFilamentId, setEditingFilamentId] = useState<string | null>(null);
  const [isMaterialDropdownOpen, setIsMaterialDropdownOpen] = useState(false);

  const [isPartModalOpen, setIsPartModalOpen] = useState(false);
  const [editingPartId, setEditingPartId] = useState<string | null>(null);
  const [isPartCategoryDropdownOpen, setIsPartCategoryDropdownOpen] = useState(false);

  const [orders, setOrders] = useState<Order[]>([]);
  const [filaments, setFilaments] = useState<Filament[]>([]);
  const [replacementParts, setReplacementParts] = useState<ReplacementPart[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (user) {
      loadData();
    } else {
      setIsLoading(false);
    }
  }, [user]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      const [fetchedOrders, fetchedFilaments, fetchedParts] = await Promise.all([
        fetchOrders(),
        fetchFilaments(),
        fetchParts()
      ]);
      setOrders(fetchedOrders);
      setFilaments(fetchedFilaments);
      setReplacementParts(fetchedParts);
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const INITIAL_CALC_INPUTS = {
    printingTime: 0,
    partWeight: 0,
    filamentCostPerKg: 80,
    filamentLossPercentage: 8,
    printerConsumption: 0.12,
    kWhCost: 0.70,
    laborHourValue: 2,
    laborTimeSpent: 0,
    printerLifespan: 3000,
    maintenanceBudget: 1000,
    maintenancePerHour: 0.33,
    fixedMonthlyCosts: 200,
    productiveHoursMonth: 720,
    profitMargin: 50
  };

  const [calcInputs, setCalcInputs] = useState(() => {
    const saved = localStorage.getItem('calc_defaults');
    return saved ? JSON.parse(saved) : INITIAL_CALC_INPUTS;
  });

  const handleSaveDefaults = () => {
    localStorage.setItem('calc_defaults', JSON.stringify(calcInputs));
    alert('Valores salvos como seus novos padrões!');
  };

  const handleResetDefaults = () => {
    if (confirm('Deseja restaurar os valores originais?')) {
      setCalcInputs(INITIAL_CALC_INPUTS);
      localStorage.removeItem('calc_defaults');
      setNewOrder(EMPTY_ORDER);
    }
  };

  const statusOptions: OrderStatus[] = ['Orçamento', 'Produção', 'Finalizado', 'Entregue', 'Cancelado'];
  const materialOptions: FilamentMaterial[] = ['PLA', 'PLA Silk', 'ABS', 'PETG', 'TPU', 'ASA', 'Nylon', 'Resina'];
  const partCategoryOptions: PartCategory[] = ['Bico (Nozzle)', 'Mesa (Bed)', 'Correia', 'Ventilador', 'Sensor', 'Extrusora', 'Eletrônica', 'Outros'];

  const metrics = useMemo(() => {
    const filteredOrders = orders.filter(o => {
      const d = new Date(o.date);
      if (dashboardScope === 'month') {
        return d.getFullYear() === selectedYear && d.getMonth() === selectedMonth;
      } else if (dashboardScope === 'year') {
        return d.getFullYear() === selectedYear;
      } else {
        if (selectedMonth === -1) return true;
        return d.getMonth() === selectedMonth;
      }
    });
    return calculateDashboardMetrics(filteredOrders, selectedYear, selectedMonth, dashboardScope);
  }, [orders, selectedYear, selectedMonth, dashboardScope]);

  const statusCounts = useMemo(() => {
    const basePeriodOrders = orders.filter(o => {
      const d = new Date(o.date);
      if (selectedDay) {
        return d.toISOString().split('T')[0] === selectedDay;
      }
      if (dashboardScope === 'month') {
        return d.getFullYear() === selectedYear && d.getMonth() === selectedMonth;
      } else if (dashboardScope === 'year') {
        return d.getFullYear() === selectedYear;
      } else {
        if (selectedMonth === -1) return true;
        return d.getMonth() === selectedMonth;
      }
    });

    const ordersTabBaseOrders = orders.filter(o => {
      const d = new Date(o.date);
      if (selectedDay) return d.toISOString().split('T')[0] === selectedDay;
      if (selectedMonth === -1) return d.getFullYear() === selectedYear;
      return d.getFullYear() === selectedYear && d.getMonth() === selectedMonth;
    });

    const isDashboard = activeTab === 'dashboard';
    const activeOrders = isDashboard ? basePeriodOrders : ordersTabBaseOrders;

    const counts: Record<string, number> = {
      'Todos': activeOrders.length,
      'Orçamento': activeOrders.filter(o => o.status === 'Orçamento').length,
      'Produção': activeOrders.filter(o => o.status === 'Produção').length,
      'Finalizado': activeOrders.filter(o => o.status === 'Finalizado').length,
      'Entregue': activeOrders.filter(o => o.status === 'Entregue').length,
      'Cancelado': activeOrders.filter(o => o.status === 'Cancelado').length,
    };
    return counts;
  }, [orders, selectedYear, selectedMonth, selectedDay, activeTab, dashboardScope]);

  const filteredOrdersList = useMemo(() => {
    return orders.filter(o => {
      const d = new Date(o.date);
      let matchesTime = false;
      if (selectedDay) {
        matchesTime = d.toISOString().split('T')[0] === selectedDay;
      } else if (selectedMonth === -1) {
        matchesTime = d.getFullYear() === selectedYear;
      } else {
        matchesTime = d.getFullYear() === selectedYear && d.getMonth() === selectedMonth;
      }
      const matchesStatus = statusFilter === 'Todos' || o.status === statusFilter;
      return matchesTime && matchesStatus;
    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  }, [orders, selectedYear, selectedMonth, selectedDay, statusFilter]);

  const profitMarginPercent = useMemo(() => {
    if (metrics.totalRevenue === 0) return 0;
    return (metrics.totalProfit / metrics.totalRevenue) * 100;
  }, [metrics.totalProfit, metrics.totalRevenue]);

  const calcResults = useMemo(() => {
    const filamentGrams = calcInputs.partWeight * (1 + calcInputs.filamentLossPercentage / 100);
    const materialCost = (filamentGrams / 1000) * calcInputs.filamentCostPerKg;
    const energyCost = calcInputs.printingTime * calcInputs.printerConsumption * calcInputs.kWhCost;
    const laborCost = calcInputs.laborTimeSpent * calcInputs.laborHourValue;
    const hourlyMaintenanceRate = calcInputs.maintenanceBudget / Math.max(1, calcInputs.printerLifespan);
    const maintenanceCost = hourlyMaintenanceRate * calcInputs.printingTime;
    const fixedRateCost = (calcInputs.fixedMonthlyCosts / Math.max(1, calcInputs.productiveHoursMonth)) * calcInputs.printingTime;
    const subtotal = materialCost + energyCost + laborCost + maintenanceCost + fixedRateCost;
    const profit = subtotal * (calcInputs.profitMargin / 100);
    const total = subtotal + profit;

    return { materialCost, energyCost, laborCost, maintenanceCost, fixedRateCost, subtotal, profit, total, hourlyMaintenanceRate };
  }, [calcInputs]);
